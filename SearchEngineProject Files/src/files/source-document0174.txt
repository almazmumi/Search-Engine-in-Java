Sequence of steps[edit] In 2004, Goldsmith suggested a "problem pyramid" of "six steps which must be performed in sequence":[5] Identify the real problem, opportunity or challenge Identify the current measure(s) which show that the problem is real Identify the goal measure(s) to show the problem has been addressed and the value of meeting it Identify the "as-is" cause(s) of the problem, as it is the causes that must be solved, not the problem directly Define the business "whats" that must be delivered to meet the goal measure(s) Specify a product design how to satisfy the real business requirements However Goldsmith notes that identifying the real problem "is exceedingly difficult".[5] Complementary approaches[edit] In 2009, Alexander and Beus-Dukic proposed a set of complementary approaches for discovering requirements:[6] Identifying stakeholders Modeling goals Modeling context Discovering scenarios (or Use cases) Discovering "qualities and constraints" (Non-functional requirements) Modeling rationale and assumptions Writing definitions of terms Analyzing measurements (acceptance criteria) Analyzing priorities Alexander and Beus-Dukic suggested that these approaches could be conducted with individuals (as in interviews), with groups (as in focused meetings known as workshops, or via Electronic meeting systems), or from "things" (artifacts) such as prototypes.[6] Non-functional requirements[edit] In 2009, Miller proposed a battery of over 2,000 questions to elicit non-functional requirements.[7] Her approach is to build a stakeholder profile and then interview those stakeholders extensively. The questions are grouped into three sections, all focused on user needs:[7] Operation: how well does the system perform for daily use? Revision: how easy is it to correct errors and add functions? Transition: How easy is it to adapt to changes in the technical environment? In 2013, Murali Chemuturi suggested the usage of Ancillary Functionality Requirements instead of Non-Functional Requirements as "Non-Functional" connotes "never functional". Second, these requirements in fact fulfill some requirements which are supportive to main or Core Functionality Requirements.In systems engineering and requirements engineering, a non-functional requirement is a requirement that specifies criteria that can be used to judge the operation of a system, rather than specific behaviors. This should be contrasted with functional requirements that define specific behavior or functions. The plan for implementing functional requirements is detailed in the system design. The plan for implementing non-functional requirements is detailed in the system architecture. Broadly, functional requirements define what a system is supposed to do and non-functional requirements define how a system is supposed to be. Functional requirements are usually in the form of "system shall do <requirement>", an individual action of part of the system, perhaps explicitly in the sense of a mathematical function, a black box description input, output, process and control functional model or IPO Model. In contrast, non-functional requirements are in the form of "system shall be <requirement>", an overall property of the system as a whole or of a particular aspect and not a specific function. The systems' overall properties commonly mark the difference between whether the development project has succeeded or failed. Non-functional requirements are often called qualities of a system. Other terms for non-functional requirements are "constraints", "quality attributes", "quality goals", "quality of service requirements" and "non-behavioral requirements".[1] Informally these are sometimes called the "ilities", from attributes like stability and portability. Qualities, that is non-functional requirements, can be divided into two main categories: Execution qualities, such as security and usability, which are observable at run time. Evolution qualities, such as testability, maintainability, extensibility and scalability, which are embodied in the static structure of the software systemA system may be required to present the user with a display of the number of records in a database. This is a functional requirement. How up-to-date this number needs to be is a non-functional requirement. If the number needs to be updated in real time, the system architects must ensure that the system is capable of updating the displayed record count within an acceptably short interval of the number of records changing. Sufficient network bandwidth may be a non-functional requirement of a system. Other examples include: Accessibility Audit and control Availability (see service level agreement) Backup Capacity, current and forecast Certification Compliance Configuration management Dependency on other parties Deployment Documentation Disaster recovery Efficiency (resource consumption for given load) Effectiveness (resulting performance in relation to effort) Emotional factors (like fun or absorbing or has "Wow! Factor") Environmental protection Escrow Exploitability Extensibility (adding features, and carry-forward of customizations at next major version upgrade) Failure management Fault tolerance (e.g. Operational System Monitoring, Measuring, and Management) Legal and licensing issues or patent-infringement-avoidability Interoperability Maintainability Modifiability Network topology Open source Operability Performance / response time (performance engineering) Platform compatibility Price Privacy Portability Quality (e.g. faults discovered, faults delivered, fault removal efficacy) Recovery / recoverability (e.g. mean time to recovery - MTTR) Reliability (e.g. mean time between failures - MTBF, or availability) Reporting Resilience Resource constraints (processor speed, memory, disk space, network bandwidth, etc.) Response time Reusability Robustness Safety or Factor of safety Scalability (horizontal, vertical) Security Software, tools, standards etc. Compatibility Stability Supportability Testability Usability by target user community