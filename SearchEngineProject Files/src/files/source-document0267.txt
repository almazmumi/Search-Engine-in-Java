 An Inference Engine is a tool from artificial intelligence. The first inference engines were components of expert systems. The typical expert system consisted of a knowledge base and an inference engine. The knowledge base stored facts about the world. The inference engine applied logical rules to the knowledge base and deduced new knowledge. This process would iterate as each new fact in the knowledge base could trigger additional rules in the inference engine. Inference engines work primarily in one of two modes:forward chaining and backward chaining. Forward chaining starts with the known facts and asserts new facts. Backward chaining starts with goals, and works backward to determine what facts must be asserted so that the goals can be achieved.[1] The logic that an inference engine uses is typically represented as IF-THEN rules. The general format of such rules is IF <logical expression> THEN <logical expression>. Prior to the development of expert systems and inference engines artificial intelligence researchers focused on more powerful theorem prover environments that offered much fuller implementations of First Order Logic. For example, general statements that included universal quantification (for all X some statement is true) and existential quantification (there exists some X such that some statement is true). What researchers discovered is that the power of these theorem proving environments was also their drawback. It was far too easy to create logical expressions that could take an indeterminate or even infinite time to terminate. For example, it is common in universal quantification to make statements over an infinite set such as the set of all natural numbers. Such statements are perfectly reasonable and even required in mathematical proofs but when included in an automated theorem prover executing on a computer may cause the computer to fall into an infinite loop. Focusing on IF-THEN statements (what logicians call Modus Ponens) still gave developers a very powerful general mechanism to represent logic but one that could be used efficiently with computational resources. What is more there is some psychological research that indicates humans also tend to favor IF-THEN representations when storing complex knowledge.[2] A simple example of Modus Ponens often used in introductory logic books is "If you are human then you are mortal". This can be represented in pseudocode as: Rule1: Human(x) => Mortal(x) A trivial example of how this rule would be used in an inference engine is as follows. In forward chaining, the inference engine would findIntegrated circuits often seem to have been designed on obsolete, proprietary systems, which means that when those systems can no longer be maintained (lack of spare parts, inefficiency, etc.), the only way to incorporate the functionality into new technology is to reverse-engineer the existing chip and then re-design it using newer tools, and using the understanding gained, as a guide. Another obsolescence originated problem which can be solved by RE is the need to support (maintenance and supply for continuous operation) existing, legacy devices which are no longer supported by their OEM. any facts in the knowledge base that matched Human(x) and for each fact it found would add the new information Mortal(x) to the knowledge base. So if it found an object called Socrates that was Human it would deduce that Socrates was Mortal. In Backward Chaining the system would be given a goal, e.g. answer the question is Socrates Mortal? It would search through the knowledge base and determine if Socrates was Human and if so would assert he is also Mortal. However, in backward chaining a common technique was to integrate the inference engine with a user interface. In that way rather than simply being automated the system could now be interactive. In this trivial example if the system was given the goal to answer the question if Socrates was Mortal and it didn't yet know if he was human it would generate a window to ask the user the question "Is Socrates Human?" and would then use that information accordingly. This innovation of integrating the inference engine with a user interface led to the second early advancement of expert systems: explanation capabilities. The explicit representation of knowledge as rules rather than code made it possible to generate explanations to users. Both explanations in real time and after the fact. So if the system asked the user "Is Socrates Human?" the user may wonder why she was being asked that question and the system would use the chain of rules to explain why it was currently trying to assertain that bit of knowledge: i.e., it needs to determine if Socrates is Mortal and to do that needs to determine if he is Human. At first these explanations were not much different than the standard debugging information that developers deal with when debugging any system. However, an active area of research was utilizing natural language technology to ask, understand, and generate questions and explanations using natural languages rather than computer formalisms.[3] An inference engine cycles through three sequential steps: match rules, select rules, and execute rules. The execution of the rules will often result in new facts or goals being added to the knowledge base which will trigger the cycle to repeat. This cycle continues until no new rules can be matched. In the first step, match rules, the inference engine finds all of the rules that are triggered by the current contents of the knowledge base. In forward chaining the engine looks for rules where the antecedent (left hand side) matches some fact in the knowledge base. In backward chaining the engine looks for antecedents that can satisfy one of the current goals. In the second step select rules, the inference engine prioritizes the various rules that were matched to determine the order to execute them. In the final step, execute rules, the engine executes each matched rule in the order determined in step two and then iterates back to step one again. The cycle continues until no new rules are matched.[4] 